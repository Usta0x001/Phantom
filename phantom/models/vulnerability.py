"""
Vulnerability Models

Core Pydantic models for representing security vulnerabilities
with structured evidence and verification status.
"""

from datetime import UTC, datetime
from enum import Enum
from typing import Any
from pydantic import BaseModel, ConfigDict, Field


class VulnerabilitySeverity(str, Enum):
    """CVSS-aligned severity levels."""
    CRITICAL = "critical"  # CVSS 9.0-10.0
    HIGH = "high"          # CVSS 7.0-8.9
    MEDIUM = "medium"      # CVSS 4.0-6.9
    LOW = "low"            # CVSS 0.1-3.9
    INFO = "info"          # Informational finding


class VulnerabilityStatus(str, Enum):
    """Lifecycle status of a vulnerability finding."""
    DETECTED = "detected"      # Tool reported it
    VERIFIED = "verified"      # Exploit confirmed it
    EXPLOITED = "exploited"    # Successfully exploited
    FALSE_POSITIVE = "false_positive"  # Verification failed
    MITIGATED = "mitigated"    # Target was patched


class VulnerabilityEvidence(BaseModel):
    """Evidence supporting a vulnerability finding."""
    
    type: str = Field(..., description="Type of evidence: request, response, screenshot, log, payload")
    description: str = Field(..., description="Human-readable description")
    data: str = Field(..., description="Raw evidence data (truncated if needed)")
    timestamp: datetime = Field(default_factory=lambda: datetime.now(UTC))
    tool: str | None = Field(default=None, description="Tool that produced this evidence")
    
    model_config = ConfigDict(
        json_encoders={datetime: lambda v: v.isoformat()},
    )


class Vulnerability(BaseModel):
    """
    Core vulnerability model.
    
    Represents a security finding with full context for:
    - Triage (severity, status)
    - Reproduction (evidence, payloads)
    - Reporting (CVE refs, remediation)
    """
    
    # Identification
    id: str = Field(..., description="Unique ID: vuln-{hash}")
    name: str = Field(..., description="Vulnerability name/title")
    vulnerability_class: str = Field(..., description="Category: sqli, xss, rce, ssrf, idor, etc.")
    
    # Severity & Status
    severity: VulnerabilitySeverity = Field(default=VulnerabilitySeverity.MEDIUM)
    status: VulnerabilityStatus = Field(default=VulnerabilityStatus.DETECTED)
    cvss_score: float | None = Field(default=None, ge=0.0, le=10.0)
    
    # Location
    target: str = Field(..., description="Target URL or host")
    endpoint: str | None = Field(default=None, description="Specific endpoint/path")
    parameter: str | None = Field(default=None, description="Vulnerable parameter")
    method: str | None = Field(default=None, description="HTTP method if applicable")
    
    # Technical Details
    description: str = Field(..., description="Technical description")
    payload: str | None = Field(default=None, description="Working exploit payload")
    evidence: list[VulnerabilityEvidence] = Field(default_factory=list)
    
    # References
    cve_ids: list[str] = Field(default_factory=list, description="CVE identifiers")
    cwe_ids: list[str] = Field(default_factory=list, description="CWE identifiers")
    references: list[str] = Field(default_factory=list, description="URLs to advisories")
    
    # Remediation
    remediation: str | None = Field(default=None, description="Fix recommendation")
    
    # Metadata
    detected_by: str = Field(..., description="Tool that found this")
    detected_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    verified_at: datetime | None = Field(default=None)
    verified_by: str | None = Field(default=None, description="Verification method/tool")
    
    # Raw data for debugging
    raw_finding: dict[str, Any] | None = Field(default=None, exclude=True)
    
    model_config = ConfigDict(
        json_encoders={datetime: lambda v: v.isoformat()},
    )
    
    def mark_verified(self, verified_by: str, payload: str | None = None) -> None:
        """Mark vulnerability as verified with optional payload."""
        self.status = VulnerabilityStatus.VERIFIED
        self.verified_at = datetime.now(UTC)
        self.verified_by = verified_by
        if payload:
            self.payload = payload
    
    def mark_false_positive(self, reason: str) -> None:
        """Mark as false positive with reason."""
        self.status = VulnerabilityStatus.FALSE_POSITIVE
        self.evidence.append(VulnerabilityEvidence(
            type="log",
            description=f"False positive: {reason}",
            data=reason,
            tool="verification",
        ))
    
    def add_evidence(self, evidence_type: str, description: str, data: str, tool: str | None = None) -> None:
        """Add evidence to the vulnerability."""
        self.evidence.append(VulnerabilityEvidence(
            type=evidence_type,
            description=description,
            data=data[:10000],  # Truncate large evidence
            tool=tool,
        ))
    
    def to_report_dict(self) -> dict[str, Any]:
        """Export for reporting (excludes internal fields)."""
        return {
            "id": self.id,
            "name": self.name,
            "class": self.vulnerability_class,
            "severity": self.severity.value,
            "status": self.status.value,
            "cvss": self.cvss_score,
            "target": self.target,
            "endpoint": self.endpoint,
            "parameter": self.parameter,
            "description": self.description,
            "payload": self.payload,
            "evidence_count": len(self.evidence),
            "cve_ids": self.cve_ids,
            "cwe_ids": self.cwe_ids,
            "remediation": self.remediation,
            "detected_by": self.detected_by,
            "detected_at": self.detected_at.isoformat(),
            "verified": self.status == VulnerabilityStatus.VERIFIED,
            "verified_by": self.verified_by,
        }
    
    @classmethod
    def from_nuclei(cls, finding: dict[str, Any]) -> "Vulnerability":
        """Create from Nuclei JSON output."""
        import hashlib
        
        template_id = finding.get("template-id", "unknown")
        host = finding.get("host", "unknown")
        matched_at = finding.get("matched-at", host)
        
        vuln_id = f"vuln-{hashlib.sha256(f'{template_id}:{matched_at}'.encode()).hexdigest()[:12]}"
        
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "info": VulnerabilitySeverity.INFO,
        }
        
        info = finding.get("info", {})
        
        return cls(
            id=vuln_id,
            name=info.get("name", template_id),
            vulnerability_class=finding.get("type", "unknown"),
            severity=severity_map.get(info.get("severity", "medium"), VulnerabilitySeverity.MEDIUM),
            target=host,
            endpoint=matched_at,
            description=info.get("description", "Detected by Nuclei template"),
            detected_by="nuclei",
            cve_ids=[ref for ref in info.get("reference", []) if "CVE-" in str(ref).upper()],
            cwe_ids=[f"CWE-{cwe}" for cwe in info.get("classification", {}).get("cwe-id", [])],
            references=info.get("reference", []),
            remediation=info.get("remediation"),
            raw_finding=finding,
        )
    
    @classmethod
    def from_sqlmap(cls, result: dict[str, Any], url: str) -> "Vulnerability":
        """Create from SQLMap result."""
        import hashlib
        
        vuln_id = f"vuln-{hashlib.sha256(f'sqli:{url}'.encode()).hexdigest()[:12]}"
        
        payloads = result.get("payloads", [])
        payload_str = payloads[0] if payloads else None
        
        return cls(
            id=vuln_id,
            name="SQL Injection",
            vulnerability_class="sqli",
            severity=VulnerabilitySeverity.CRITICAL,
            target=url,
            endpoint=url,
            parameter=result.get("parameter"),
            description=f"SQL Injection detected. DBMS: {result.get('dbms', 'unknown')}",
            payload=payload_str,
            detected_by="sqlmap",
            cwe_ids=["CWE-89"],
            remediation="Use parameterized queries/prepared statements",
            raw_finding=result,
        )
    
    @classmethod
    def from_nmap_vuln(cls, vuln_data: dict[str, Any], host: str, port: int) -> "Vulnerability":
        """Create from nmap NSE vuln script output."""
        import hashlib
        
        title = vuln_data.get("title", "Unknown Vulnerability")
        vuln_id = f"vuln-{hashlib.sha256(f'{title}:{host}:{port}'.encode()).hexdigest()[:12]}"
        
        return cls(
            id=vuln_id,
            name=title,
            vulnerability_class="network",
            severity=VulnerabilitySeverity.HIGH,  # NSE vuln scripts usually find high-sev issues
            target=host,
            endpoint=f"{host}:{port}",
            description=vuln_data.get("details", title),
            detected_by="nmap",
            raw_finding=vuln_data,
        )
