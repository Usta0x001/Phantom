"""Nuclei custom template generation â€” produce YAML templates from Phantom
scan findings so users can re-run targeted checks.

Usage::

    from phantom.core.nuclei_templates import TemplateGenerator
    tg = TemplateGenerator()
    yaml_str = tg.from_finding({
        "title": "SQL Injection in login",
        "severity": "high",
        "endpoint": "/api/login",
        "method": "POST",
        "cve": "CVE-2024-1234",
        "description": "...",
        "poc_script_code": "curl -X POST ...",
    })
"""

from __future__ import annotations

import hashlib
import re
import textwrap
from datetime import datetime, timezone
from pathlib import Path
from typing import Any


def _yaml_escape(value: str) -> str:
    """Escape a string for safe inclusion in YAML values."""
    # Replace characters that would break YAML structure
    value = value.replace("\\", "\\\\")
    value = value.replace('"', '\\"')
    value = value.replace("\n", " ")
    value = value.replace("\r", "")
    value = value.replace(":", "\\:")  # colon in flow context
    value = value.replace("#", "\\#")  # comment char
    value = value.replace("---", "\\-\\-\\-")  # doc separator
    return value


class TemplateGenerator:
    """Generate Nuclei YAML templates from Phantom findings."""

    SEVERITY_MAP = {
        "critical": "critical",
        "high": "high",
        "medium": "medium",
        "low": "low",
        "info": "info",
    }

    def __init__(self, *, author: str = "phantom-auto", output_dir: str | Path | None = None) -> None:
        self.author = author
        self.output_dir = Path(output_dir) if output_dir else None
        if self.output_dir:
            self.output_dir.mkdir(parents=True, exist_ok=True)

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def from_finding(self, finding: dict[str, Any]) -> str:
        """Generate a Nuclei template YAML string from a single finding."""
        template_id = self._make_id(finding)
        title = _yaml_escape(finding.get("title", "Untitled Finding"))
        severity = self.SEVERITY_MAP.get(
            (finding.get("severity") or "info").lower(), "info"
        )
        description = _yaml_escape(finding.get("description", "Auto-generated by Phantom.")[:500])
        endpoint = finding.get("endpoint", "/")
        method = (finding.get("method") or "GET").upper()
        cve = finding.get("cve", "")
        poc = finding.get("poc_script_code", "")

        # Try to extract request body from PoC
        body = self._extract_body(poc, method)

        # Build matchers from description / title
        matchers = self._build_matchers(finding)

        # Compose template
        lines = [
            f"id: {template_id}",
            "",
            "info:",
            f"  name: {title}",
            f"  author: {self.author}",
            f"  severity: {severity}",
            f"  description: |",
            f"    {description[:500]}",
        ]

        if cve:
            lines += [
                "  classification:",
                f"    cve-id: {cve}",
            ]

        lines += [
            f"  tags: phantom,auto-generated",
            "",
            "http:",
            f"  - method: {method}",
            f"    path:",
            f'      - "{{{{BaseURL}}}}{endpoint}"',
        ]

        if body and method in ("POST", "PUT", "PATCH"):
            lines += [
                f"    body: |",
                f"      {body}",
            ]

        # Headers for POST
        if method in ("POST", "PUT", "PATCH"):
            lines += [
                "    headers:",
                "      Content-Type: application/json",
            ]

        lines += [
            "",
            "    matchers-condition: and",
            "    matchers:",
        ]

        for m in matchers:
            lines.append(f"      - type: {m['type']}")
            if "status" in m:
                lines.append(f"        status:")
                for s in m["status"]:
                    lines.append(f"          - {s}")
            if "words" in m:
                lines.append(f"        words:")
                for w in m["words"]:
                    lines.append(f'          - "{w}"')
            if "part" in m:
                lines.append(f"        part: {m['part']}")

        template = "\n".join(lines) + "\n"

        # Optionally write to file
        if self.output_dir:
            out_path = self.output_dir / f"{template_id}.yaml"
            out_path.write_text(template, encoding="utf-8")

        return template

    def from_findings(self, findings: list[dict[str, Any]]) -> list[str]:
        """Generate templates for multiple findings.  Returns list of YAML strings."""
        return [self.from_finding(f) for f in findings]

    def bulk_export(
        self,
        findings: list[dict[str, Any]],
        output_dir: str | Path,
    ) -> list[Path]:
        """Write one ``.yaml`` template per finding into ``output_dir``."""
        out = Path(output_dir)
        out.mkdir(parents=True, exist_ok=True)
        paths: list[Path] = []
        for f in findings:
            template_id = self._make_id(f)
            yaml_str = self.from_finding(f)
            p = out / f"{template_id}.yaml"
            p.write_text(yaml_str, encoding="utf-8")
            paths.append(p)
        return paths

    # ------------------------------------------------------------------
    # Internals
    # ------------------------------------------------------------------

    @staticmethod
    def _make_id(finding: dict[str, Any]) -> str:
        """Derive a safe template ID from the finding, unique via content hash."""
        title = finding.get("title", "untitled")
        slug = re.sub(r"[^a-zA-Z0-9]+", "-", title.lower()).strip("-")[:40]
        # Hash the full finding to avoid collisions
        content_hash = hashlib.sha256(
            str(sorted(finding.items())).encode()
        ).hexdigest()[:8]
        return f"phantom-{slug}-{content_hash}"

    @staticmethod
    def _extract_body(poc: str, method: str) -> str:
        """Try to extract POST body from a curl-like PoC command."""
        if not poc or method not in ("POST", "PUT", "PATCH"):
            return ""
        # Match curl -d or --data
        match = re.search(r"""(?:-d|--data(?:-raw)?)\s+['"](.+?)['"]""", poc, re.S)
        if match:
            return match.group(1)
        return ""

    @staticmethod
    def _build_matchers(finding: dict[str, Any]) -> list[dict[str, Any]]:
        """Derive reasonable Nuclei matchers from the finding metadata."""
        matchers: list[dict[str, Any]] = []

        # Status code matcher
        matchers.append({"type": "status", "status": [200]})

        # Word matchers from common vulnerability indicators
        title = (finding.get("title") or "").lower()
        words: list[str] = []

        if "sql" in title or "injection" in title:
            words.extend(["error", "syntax", "mysql", "postgresql", "sqlite"])
        elif "xss" in title or "cross-site" in title:
            words.extend(["<script", "alert(", "onerror"])
        elif "ssrf" in title:
            words.extend(["internal", "localhost", "127.0.0.1"])
        elif "lfi" in title or "file inclusion" in title:
            words.extend(["root:", "/etc/passwd", "win.ini"])
        elif "rce" in title or "command" in title:
            words.extend(["uid=", "root", "whoami"])

        if words:
            matchers.append({"type": "word", "words": words[:3], "part": "body"})

        return matchers
